Nice — the native .so built successfully (return code 0) — great progress! The ModuleNotFoundError happens because Python can't find that .so file on sys.path. You compiled the module into /home/work/dcvc/dcvc_try_p/src/cpp/MLCodec_extensions_cpp.so, but your notebook's sys.path contains the repo root (/home/work/dcvc/dcvc_try_p) — not src/cpp. Python only searches directories listed in sys.path when importing a module by name.

Two quick fixes (both safe). Run one of these notebook cells.

Option 1 — add the src/cpp folder to sys.path (fast, temporary; recommended):

import sys
from pathlib import Path

cpp_dir = str(Path("/home/work/dcvc/dcvc_try_p/src/cpp").resolve())
if cpp_dir not in sys.path:
    sys.path.insert(0, cpp_dir)
print("Inserted into sys.path:", cpp_dir)

# Try import
import importlib
try:
    m = importlib.import_module("MLCodec_extensions_cpp")
    print("Imported MLCodec_extensions_cpp:", m)
except Exception as e:
    print("Import failed:", repr(e))

Option 2 — move the built shared object to the repo root so it's already on sys.path (persistent for this session):

import shutil
from pathlib import Path
repo_root = Path("/home/work/dcvc/dcvc_try_p").resolve()
cpp_dir = repo_root / "src" / "cpp"
so = cpp_dir / "MLCodec_extensions_cpp.so"
dst = repo_root / "MLCodec_extensions_cpp.so"
print("Moving", so, "->", dst)
shutil.copy2(so, dst)
print("Copied. Now try importing:")

import sys, importlib
if str(repo_root) not in sys.path:
    sys.path.insert(0, str(repo_root))
try:
    m = importlib.import_module("MLCodec_extensions_cpp")
    print("Imported MLCodec_extensions_cpp:", m)
except Exception as e:
    print("Import failed:", repr(e))

After import succeeds, re-run the test subprocess. Paste and run this cell next (it will stream output):

# Re-run test_video.py as subprocess now that extension should be importable
import subprocess, os, sys
from pathlib import Path

repo_root = Path("/home/work/dcvc/dcvc_try_p").resolve()
env = os.environ.copy()
env["PYTHONPATH"] = str(repo_root) + ":" + env.get("PYTHONPATH", "")

cmd = [
    sys.executable, str(repo_root / "test_video.py"),
    "--model_path_i", "./checkpoints/cvpr2025_image.pth.tar",
    "--model_path_p", "./checkpoints/cvpr2025_video.pth.tar",
    "--rate_num", "4",
    "--test_config", "./dataset_config_example_yuv420.json",
    "--cuda", "1",
    "-w", "1",
    "--write_stream", "1",
    "--force_zero_thres", "0.12",
    "--output_path", "output.json",
    "--force_intra_period", "-1",
    "--reset_interval", "64",
    "--force_frame_num", "-1",
    "--check_existing", "0",
    "--verbose", "0",
]

print("Running:", " ".join(cmd))
proc = subprocess.Popen(cmd, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
try:
    for line in proc.stdout:
        print(line, end="")
except KeyboardInterrupt:
    proc.terminate()
    proc.wait()
    print("\nSubprocess terminated by user.")
finally:
    proc.stdout.close()
    rc = proc.wait()
    print(f"\nSubprocess finished with return code: {rc}")

Why this works: Python imports extension modules from directories present in sys.path. Adding the directory where the .so lives or copying the .so into an existing sys.path entry makes the module discoverable.

Pick Option 1 (temporary sys.path change) unless you prefer the .so to live at repo root. Run the import cell, then run the subprocess cell and paste the output if any new error appears — I’ll help interpret it.

