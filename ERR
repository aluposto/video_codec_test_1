# Run test_video.py as a subprocess (recommended â€” avoids multiprocessing pickling errors)
import subprocess, sys, os
from pathlib import Path

repo_root = Path("/home/work/dcvc/dcvc_try_p").resolve()
# ensure the subprocess sees repo_root on PYTHONPATH
env = os.environ.copy()
env["PYTHONPATH"] = str(repo_root) + (":" + env.get("PYTHONPATH", "")) if env.get("PYTHONPATH") else str(repo_root)

cmd = [
    sys.executable, str(repo_root / "test_video.py"),
    "--model_path_i", "./checkpoints/cvpr2025_image.pth.tar",
    "--model_path_p", "./checkpoints/cvpr2025_video.pth.tar",
    "--rate_num", "4",
    "--test_config", "./dataset_config_example_yuv420.json",
    "--cuda", "1",
    "-w", "1",
    "--write_stream", "1",
    "--force_zero_thres", "0.12",
    "--output_path", "output.json",
    "--force_intra_period", "-1",
    "--reset_interval", "64",
    "--force_frame_num", "-1",
    "--check_existing", "0",
    "--verbose", "0",
]

print("Running:", " ".join(cmd))
proc = subprocess.Popen(cmd, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)

# Stream output live to notebook
try:
    for line in proc.stdout:
        print(line, end="")   # already contains newline
except KeyboardInterrupt:
    proc.terminate()
    proc.wait()
    print("\nSubprocess terminated by user.")
finally:
    proc.stdout.close()
    rc = proc.wait()
    print(f"\nSubprocess finished with return code: {rc}")
