# Patch: make RansEncoderLib.flush() robust in src/python/mlcodec_rans_py.py
from pathlib import Path
p = Path("src/python/mlcodec_rans_py.py")
text = p.read_text()

old_start = "    def flush(self):"
if old_start not in text:
    print("Can't find flush() method in file; aborting patch. Showing first 200 chars of file:")
    print(text[:200])
else:
    # Build the new flush method body (indented with 4 spaces)
    new_flush = '''
    def flush(self):
        out = []
        r = RansEncInit()
        # process pending tasks in reverse order (like the C++ implementation)
        for task in reversed(self._pending):
            if task[0] == "y":
                _, symbols, group = task
                rans_sym_grp = self._ransSymbols[group]
                for combined in reversed(symbols):
                    cdf_idx = combined & 0xff
                    # entry might be tuple/list/np.array-like; take first two values as start,rng
                    entry = rans_sym_grp[cdf_idx]
                    start = int(entry[0])
                    rng = int(entry[1])
                    r = RansEncPut(r, out, start, rng)
            elif task[0] == "z":
                _, symbols, group, start_offset, per_channel = task
                rans_sym_grp = self._ransSymbols[group]
                for i in range(len(symbols)-1, -1, -1):
                    cdf_idx = i // per_channel + start_offset
                    entry = rans_sym_grp[cdf_idx]
                    start = int(entry[0])
                    rng = int(entry[1])
                    r = RansEncPut(r, out, start, rng)
        # flush final state
        RansEncFlush(r, out)
        # produced bytes are appended LSB-first; reverse to match C++ stream order
        self._stream = bytearray(reversed(out))
        self._pending.clear()
'''

    # Replace the existing flush method by locating its start and replacing up to the next blank line after it
    import re
    # find the def flush(...) block and replace it
    pattern = r"(?ms)\\n\\s*def\\s+flush\\s*\\(self\\):.*?\\n\\s*def\\s"
    m = re.search(pattern, "\\n" + text)
    if m:
        # we matched up to the next def â€” extract prefix and suffix
        start_idx = m.start()
        # find the index where the next def begins
        next_def_pos = m.end() - len("\\n    def ")
        prefix = text[:start_idx+1]  # include first newline used in the search
        suffix = text[next_def_pos+1 - len("def "):]  # keep 'def ' for the following def
        new_text = prefix + new_flush + suffix
    else:
        # fallback: replace from "def flush" until "def get_encoded_stream"
        new_text = re.sub(r"(?ms)def\\s+flush\\s*\\(self\\):.*?\\n\\s*def\\s+get_encoded_stream", 
                          "def flush(self):\\n" + new_flush.strip() + "\\n\\ndef get_encoded_stream", text)

    p.write_text(new_text)
    print("Patched flush() in", p)
