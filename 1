# Force use of conda env libstdc++ at runtime, retry import, and re-run test script
import os, sys, subprocess, importlib
from pathlib import Path

repo_root = Path("/home/work/dcvc/dcvc_try_p").resolve()
cpp_dir = repo_root / "src" / "cpp"
so_path = cpp_dir / "MLCodec_extensions_cpp.so"

# 1) Prepend conda env lib dir to LD_LIBRARY_PATH for this process and subprocesses
conda_env_lib = "/home/work/dcvc/miniconda3/envs/dcvc_rt_env_1/lib"
old_ld = os.environ.get("LD_LIBRARY_PATH", "")
if conda_env_lib not in old_ld.split(":"):
    os.environ["LD_LIBRARY_PATH"] = conda_env_lib + (":" + old_ld if old_ld else "")
print("LD_LIBRARY_PATH now starts with:", os.environ["LD_LIBRARY_PATH"].split(":")[0])

# 2) Ensure cpp_dir is on sys.path for imports
if str(cpp_dir) not in sys.path:
    sys.path.insert(0, str(cpp_dir))
print("sys.path[0:4]:", sys.path[:4])

# 3) Try import
print("\nAttempting to import MLCodec_extensions_cpp...")
try:
    m = importlib.import_module("MLCodec_extensions_cpp")
    print("Imported MLCodec_extensions_cpp:", m)
except Exception as e:
    print("Import failed:", repr(e))
    # show ldd diagnostics to understand which lib is picked
    if so_path.exists():
        print("\n--- ldd for the built .so ---")
        proc = subprocess.run(f"ldd {so_path}", shell=True, capture_output=True, text=True)
        print(proc.stdout)
        print(proc.stderr)
    raise

# 4) If import succeeded, show ldd to verify libstdc++ now points to conda env lib
print("\nImport succeeded. Verifying linked libraries (ldd):")
proc = subprocess.run(f"ldd {so_path}", shell=True, capture_output=True, text=True)
print(proc.stdout)

# 5) Re-run test_video.py as subprocess with LD_LIBRARY_PATH preserved
print("\nRe-running test_video.py with updated LD_LIBRARY_PATH (streams output)...")
env = os.environ.copy()
env["PYTHONPATH"] = str(repo_root) + ":" + env.get("PYTHONPATH", "")
# ensure subprocess uses same LD_LIBRARY_PATH
env["LD_LIBRARY_PATH"] = os.environ["LD_LIBRARY_PATH"]

cmd_list = [
    sys.executable, str(repo_root / "test_video.py"),
    "--model_path_i", "./checkpoints/cvpr2025_image.pth.tar",
    "--model_path_p", "./checkpoints/cvpr2025_video.pth.tar",
    "--rate_num", "4",
    "--test_config", "./dataset_config_example_yuv420.json",
    "--cuda", "1",
    "-w", "1",
    "--write_stream", "1",
    "--force_zero_thres", "0.12",
    "--output_path", "output.json",
    "--force_intra_period", "-1",
    "--reset_interval", "64",
    "--force_frame_num", "-1",
    "--check_existing", "0",
    "--verbose", "0",
]

print("Running:", " ".join(cmd_list))
proc = subprocess.Popen(cmd_list, env=env, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
try:
    for line in proc.stdout:
        print(line, end="")
except KeyboardInterrupt:
    proc.terminate()
    proc.wait()
    print("\nSubprocess terminated by user.")
finally:
    proc.stdout.close()
    rc = proc.wait()
    print(f"\nSubprocess finished with return code: {rc}")
