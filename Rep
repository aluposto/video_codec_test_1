# Patch + test: overwrite the pure-Python rANS module with corrected indexing, reload, and smoke-test.
from pathlib import Path
import importlib, sys
ROOT = Path(".").resolve()
file_path = ROOT / "src" / "python" / "mlcodec_rans_py.py"

file_text = r'''
# Robust pure-Python implementation of rANS encode/decode for testing.
# Correctly handles nested _ransSymbols[group][cdf_idx][symbol_value] representation.

from typing import List
import numpy as np

SCALE_BITS = 16
RANS_SHIFT_BITS = 23
RANS_BYTE_L = (1 << RANS_SHIFT_BITS)
ENC_RENORM_SHIFT_BITS = RANS_SHIFT_BITS - SCALE_BITS + 8
DEC_MASK = ((1 << SCALE_BITS) - 1)

def RansEncInit():
    return RANS_BYTE_L

def RansEncPut(r, out_buf, start, freq):
    x_max = freq << ENC_RENORM_SHIFT_BITS
    while r >= x_max:
        out_buf.append(r & 0xff)
        r >>= 8
    r = ((r // freq) << SCALE_BITS) + (r % freq) + start
    return r

def RansEncFlush(r, out_buf):
    out_buf.append((r >> 0) & 0xff)
    out_buf.append((r >> 8) & 0xff)
    out_buf.append((r >> 16) & 0xff)
    out_buf.append((r >> 24) & 0xff)

def RansDecInit(buf, ptr_index=0):
    r = (buf[ptr_index] | (buf[ptr_index+1] << 8) | (buf[ptr_index+2] << 16) | (buf[ptr_index+3] << 24))
    return r, ptr_index + 4

def RansDecGet(r):
    return r & DEC_MASK

def RansDecAdvance(r, buf, ptr_index, start, freq):
    r = freq * (r >> SCALE_BITS) + (r & DEC_MASK) - start
    while r < RANS_BYTE_L:
        r = (r << 8) | buf[ptr_index]
        ptr_index += 1
    return r, ptr_index

def pmf_to_quantized_cdf(pmf: List[float], precision: int):
    cdf = [0] * (len(pmf) + 1)
    for i, p in enumerate(pmf):
        cdf[i+1] = int(round(p * (1 << precision) + 0.5))
    total = sum(cdf)
    if total == 0:
        total = 1
    for i in range(len(cdf)):
        cdf[i] = int(((1 << precision) * cdf[i]) / total)
    for i in range(1, len(cdf)):
        cdf[i] += cdf[i-1]
    cdf[-1] = 1 << precision

    # repair zeros
    n = len(cdf) - 1
    for i in range(n):
        if cdf[i] == cdf[i+1]:
            best_freq = 0xffffffff
            best_j = -1
            for j in range(n):
                freq = cdf[j+1] - cdf[j]
                if freq > 1 and freq < best_freq:
                    best_freq = freq
                    best_j = j
            assert best_j != -1
            if best_j < i:
                for j in range(best_j+1, i+1):
                    cdf[j] -= 1
            else:
                for j in range(i+1, best_j+1):
                    cdf[j] += 1
    return cdf

class RansEncoderLib:
    def __init__(self):
        self._stream = bytearray()
        self._ransSymbols = []
        self._cdfs_sizes = []
        self._offsets = []
        self._pending = []

    def add_cdf(self, cdfs: List[List[int]], cdfs_sizes: List[int], offsets: List[int]):
        # cdfs is list of lists (each inner list is a CDF array)
        # Convert to grp: list of cdfs, where each cdf is a list of (start, range)
        grp = []
        for cdf in cdfs:
            sym = []
            for j in range(len(cdf)-1):
                start = int(cdf[j])
                rng = int(cdf[j+1] - cdf[j])
                sym.append((start, rng))
            grp.append(sym)
        self._ransSymbols.append(grp)
        self._cdfs_sizes.append([int(x) for x in cdfs_sizes])
        self._offsets.append([int(x) for x in offsets])
        return len(self._ransSymbols) - 1

    def empty_cdf_buffer(self):
        self._ransSymbols.clear()
        self._cdfs_sizes.clear()
        self._offsets.clear()

    def encode_y(self, symbols, cdf_group_index):
        arr = [int(x) for x in np.asarray(symbols).ravel().tolist()]
        self._pending.append(("y", arr, int(cdf_group_index)))

    def encode_z(self, symbols, cdf_group_index, start_offset, per_channel_size):
        arr = [int(x) for x in np.asarray(symbols).ravel().tolist()]
        self._pending.append(("z", arr, int(cdf_group_index), int(start_offset), int(per_channel_size)))

    def flush(self):
        out = []
        r = RansEncInit()
        # process pending in reverse order
        for task in reversed(self._pending):
            if task[0] == "y":
                _, symbols, group = task
                rans_sym_grp = self._ransSymbols[group]   # list of cdfs; each cdf is list of (start,range)
                for combined in reversed(symbols):
                    cdf_idx = combined & 0xff
                    s = combined >> 8
                    # rans_sym_grp[cdf_idx] should be a cdf list: list of (start,range)
                    # but group may contain only one cdf (length 1) - ensure we pick the correct cdf list
                    if cdf_idx < len(rans_sym_grp) and isinstance(rans_sym_grp[cdf_idx], (list, tuple)):
                        cdf_list = rans_sym_grp[cdf_idx]
                    else:
                        # fallback: pick first cdf in group (common case)
                        cdf_list = rans_sym_grp[0]
                    entry = cdf_list[s]
                    start = int(entry[0])
                    rng = int(entry[1])
                    r = RansEncPut(r, out, start, rng)
            elif task[0] == "z":
                _, symbols, group, start_offset, per_channel = task
                rans_sym_grp = self._ransSymbols[group]
                for i in range(len(symbols)-1, -1, -1):
                    cdf_idx = i // per_channel + start_offset
                    # choose cdf_list safely
                    if cdf_idx < len(rans_sym_grp) and isinstance(rans_sym_grp[cdf_idx], (list, tuple)):
                        cdf_list = rans_sym_grp[cdf_idx]
                    else:
                        cdf_list = rans_sym_grp[0]
                    val = symbols[i]
                    entry = cdf_list[val]
                    start = int(entry[0])
                    rng = int(entry[1])
                    r = RansEncPut(r, out, start, rng)
        RansEncFlush(r, out)
        self._stream = bytearray(reversed(out))
        self._pending.clear()

    def get_encoded_stream(self):
        return bytes(self._stream)

    def reset(self):
        self._stream = bytearray()
        self._pending.clear()

class RansDecoderLib:
    def __init__(self):
        self._stream = bytearray()
        self._ptr = 0
        self._rans = 0
        self._cdfs = []
        self._cdfs_sizes = []
        self._offsets = []
        self._decoded = []

    def set_stream(self, encoded: bytes):
        self._stream = bytearray(encoded)
        self._rans, self._ptr = RansDecInit(self._stream, 0)

    def add_cdf(self, cdfs, sizes, offsets):
        self._cdfs.append([list(map(int, row)) for row in cdfs])
        self._cdfs_sizes.append([int(x) for x in sizes])
        self._offsets.append([int(x) for x in offsets])
        return len(self._cdfs) - 1

    def empty_cdf_buffer(self):
        self._cdfs.clear()
        self._cdfs_sizes.clear()
        self._offsets.clear()

    def decode_y(self, indexes, cdf_group_index):
        idxs = [int(x) for x in np.asarray(indexes).ravel().tolist()]
        cdfs = self._cdfs[cdf_group_index]
        offsets = self._offsets[cdf_group_index]
        decoded = []
        for idx in idxs:
            cdf = cdfs[idx]
            cum = RansDecGet(self._rans)
            s = 1
            while s < len(cdf) and cdf[s] <= cum:
                s += 1
            s -= 1
            start = int(cdf[s])
            rng = int(cdf[s+1] - cdf[s])
            self._rans, self._ptr = RansDecAdvance(self._rans, self._stream, self._ptr, start, rng)
            decoded.append(int(s + offsets[idx]))
        self._decoded = decoded

    def get_decoded_tensor(self):
        return np.array(self._decoded, dtype=np.int8)
'''.lstrip()

# Write file
file_path.write_text(file_text)
print("Wrote:", file_path)

# Unload stale modules related to our python fallback and loader
to_unload = [m for m in list(sys.modules.keys()) if m.startswith("src.python") or m in ("mlcodec_rans_py","codec_loader","src.python.codec_loader")]
for m in to_unload:
    sys.modules.pop(m, None)
print("Unloaded", len(to_unload), "modules (preview):", to_unload[:6])

# Re-import loader and run the smoke test
loader = importlib.import_module("src.python.codec_loader")
importlib.reload(loader)
print("Backend in use after reload:", loader.BACKEND)

# Smoke test
import numpy as np
pmf = [0.2, 0.5, 0.3]
precision = 12
cdf = loader.pmf_to_quantized_cdf(pmf, precision)
cdfs_arr = np.array([cdf], dtype=np.int32)
cdfs_sizes = np.array([len(cdf)], dtype=np.int32)
offsets = np.array([0], dtype=np.int32)

enc = loader.RansEncoder()
idx = enc.add_cdf(cdfs_arr, cdfs_sizes, offsets)
print("cdf index:", idx)

symbols = np.array([ (0 & 0xff) | (1 << 8), (0 & 0xff) | (2 << 8) ], dtype=np.int16)
enc.encode_y(symbols, idx)
enc.flush()
stream = enc.get_encoded_stream()
print("Encoded stream len:", len(stream))
print("Encoded bytes:", np.asarray(stream, dtype=np.uint8).tolist())

dec = loader.RansDecoder()
dec.add_cdf(cdfs_arr, cdfs_sizes, offsets)
dec.set_stream(stream)
dec.decode_y(np.array([0,0], dtype=np.uint8), idx)
out = dec.get_decoded_tensor()
print("Decoded result:", out.tolist())


---

✅ What you need to do

1. Run the cell above in your notebook.


2. Copy & paste the output here.



Once I see how the nesting looks, I will give you the exact patch for flush() (1–2 lines changed) so it stops treating a nested tuple like a flat pair.

Would you like me to also prepare the ready-to-paste patch cell for mlcodec_rans_py.py so you can directly overwrite the buggy flush() once we see the structure?

