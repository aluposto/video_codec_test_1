Great — we’ll go step-by-step. I’ll give a single, easy-to-follow recipe you can run interactively. It:

clones the Microsoft DCVC repo into a fresh directory you choose,

adds a PEP-517 pyproject.toml so pip will build in an isolated environment (this avoids the Python-3.12 distutils problem),

replaces the src/cpp/setup.py with a safe, robust build script tuned to the pyrans pybind11 sources you showed,

installs compilers into your conda env (no sudo),

builds & installs the C++ pybind11 extension, and

verifies the import.


Run each numbered step in a terminal. Stop and paste the outputs here if anything fails and I’ll diagnose.


---

0) Pick a new local folder name

Choose a folder name for the fresh clone, e.g. DCVC_fresh. I’ll use that in the example commands; replace it if you prefer.


---

1) Clone the repo (fresh copy)

# replace NEW_DIR with your chosen name
NEW_DIR="DCVC_fresh"
git clone https://github.com/microsoft/DCVC.git "$NEW_DIR"
cd "$NEW_DIR"
git checkout main
pwd   # confirm you're in ~/path/to/DCVC_fresh


---

2) Add pyproject.toml at the repo root (PEP 517)

This makes pip create an isolated build environment that provides pybind11 and modern setuptools during build — solves the distutils metadata problem.

cat > pyproject.toml <<'PYPROJ'
[build-system]
requires = [
  "setuptools>=61",
  "wheel",
  "pybind11>=2.6"
]
build-backend = "setuptools.build_meta"
PYPROJ

# quick check
ls -l pyproject.toml


---

3) Replace the C++ build script with a defensive setup.py

Your repo’s C++ pybind11 sources live under src/cpp/pyrans. Create a robust src/cpp/setup.py (this avoids importing pybind11 at metadata time and uses -std=c++17):

cat > src/cpp/setup.py <<'PYSETUP'
from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext as _build_ext
import glob
import sys
from pathlib import Path

HERE = Path(__file__).resolve().parent

if __name__ == "__main__":
    if sys.platform == "win32":
        extra_compile_args = ['/std:c++17', '/O2', '/W4', '/WX', '/wd4100']
        extra_link_args = []
    else:
        # NOTE: removed -Werror to avoid build failure on warnings
        extra_compile_args = ['-std=c++17', '-O3', '-fPIC', '-Wall', '-Wextra']
        extra_link_args = []

    class build_ext(_build_ext):
        def finalize_options(self):
            super().finalize_options()
            try:
                import pybind11
                inc = pybind11.get_include()
                if inc not in self.include_dirs:
                    self.include_dirs.append(inc)
            except Exception:
                # pybind11 will be provided by pyproject build env; if missing, build will fail with a clear error.
                pass

    # Collect .cpp sources under pyrans/
    sources = glob.glob(str(HERE / 'pyrans' / '*.cpp'))
    if not sources:
        raise SystemExit("No source files found under src/cpp/pyrans/*.cpp — run this script from src/cpp/")

    ext = Extension(
        name='MLCodec_extensions_cpp',   # must match PYBIND11_MODULE name
        sources=sources,
        include_dirs=[],                 # pybind11 include appended in build_ext
        extra_compile_args=extra_compile_args,
        extra_link_args=extra_link_args,
        language='c++'
    )

    setup(
        name="MLCodec_extensions_cpp",
        ext_modules=[ext],
        cmdclass={"build_ext": build_ext},
        zip_safe=False,
        python_requires=">=3.12",
    )
PYSETUP

# verify
ls -l src/cpp/setup.py

> Why replace the original? your original setup.py imported pybind11 helpers at top-level and used py_rans/*.cpp (a different path). This safe version:

collects pyrans/*.cpp (matches your files),

defers pybind11 discovery to build time,

uses -std=c++17 like the original,

drops -Werror (avoids failing builds on harmless warnings).





---

4) Activate your Python environment (must be python 3.12)

You said you already have dcvc_rt_env. Activate it now:

conda activate dcvc_rt_env
python --version   # must show 3.12.x
which python       # should point inside your conda env

If you don't have that env yet, create it (but you said you do). If conda isn't found in your terminal, let me know and I’ll give micromamba instructions.


---

5) Install compilers & build tools into the env (no sudo)

conda install -y -c conda-forge cmake ninja gxx_linux-64 || true
# optional: install pybind11 in the env for convenience (PEP-517 will provide it anyway)
conda install -y -c conda-forge pybind11 || python -m pip install pybind11 || true

# verify tools
cmake --version || true
g++ --version || true
ninja --version || true


---

6) Upgrade packaging/build tooling

python -m pip install --upgrade pip setuptools wheel build


---

7) Build & install the C++ extension (from src/cpp)

Run the build and capture the log (so we can inspect failures if any):

cd src/cpp
python -m pip install . 2>&1 | tee ../../install_cpp_build.log

Expect pip to create an isolated build env (because of pyproject.toml) that contains pybind11 and setuptools for the build.


---

8) Quick import smoke test (same env)

If the install succeeded, test importing the module:

python - <<'PY'
import importlib, sys
try:
    m = importlib.import_module("MLCodec_extensions_cpp")
    print("Loaded:", m)
    print("RansEncoder:", hasattr(m, "RansEncoder"))
    print("RansDecoder:", hasattr(m, "RansDecoder"))
except Exception as e:
    print("Import failed:", e)
    raise
PY

If that prints the module and class availability, you’re good — the C++ bitstream code is built and importable.


---

9) If the build fails — what to paste here

If the build fails, paste these exact items (they let me diagnose quickly):

1. Tail of the build log:



tail -n 200 ../../install_cpp_build.log

2. Environment & tool diagnostics:



which python
python --version
which pip
pip --version
cmake --version || true
g++ --version || true
python -c "import sysconfig; print('site-packages:', sysconfig.get_paths()['purelib'])"
python -c "import pybind11; print('pybind11 ok, include:', pybind11.get_include())" || echo "pybind11 not importable in env"

3. If the error mentions missing headers like Python.h or pybind11/pybind11.h, paste those missing-file error lines.




---

10) Common quick fixes I’ll give you if needed

pybind11 header errors:

conda install -y -c conda-forge pybind11

Python.h missing (rare in conda env) — ensure the env's python dev headers are present:

conda install -y -c conda-forge python-dev  # if available on your platform

g++ / toolchain issues: ensure gxx_linux-64 installed (we already did).

compiler fails on warnings → we removed -Werror to avoid this; if more warnings appear we can further relax flags.



---

11) Optional: make this build reproducible / add a branch

If you want to keep your fresh copy and track changes:

cd /path/to/DCVC_fresh
git checkout -b build-fix-pyrans
git add pyproject.toml src/cpp/setup.py
git commit -m "PEP517 + robust setup.py for pyrans pybind11 build on py3.12"


---

If you want, I can produce a single pasteable one-line script that runs steps 1–8 automatically with variables (I gave earlier such a script). But since you asked to do it step-by-step, follow the numbered steps above and paste back outputs of steps 4/7/8 (or any failure log) and I’ll debug immediately.

Which step would you like to run first, or paste the live output of step 7 (install_cpp_build.log) if you already ran the build?

