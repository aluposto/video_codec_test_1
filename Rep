# Patch decoder set_stream() to try both rANS-init positions and pick the one
from pathlib import Path
import importlib, sys

root = Path(".").resolve()
file_path = root / "src" / "python" / "mlcodec_rans_py.py"

new_file_text = r'''
# Robust pure-Python implementation of rANS encode/decode for testing.
# Updated decoder.set_stream to try reading rANS state from start OR from end
# and pick the one that yields a valid cumulative frequency against loaded CDFs.

from typing import List
import numpy as np

SCALE_BITS = 16
RANS_SHIFT_BITS = 23
RANS_BYTE_L = (1 << RANS_SHIFT_BITS)
ENC_RENORM_SHIFT_BITS = RANS_SHIFT_BITS - SCALE_BITS + 8
DEC_MASK = ((1 << SCALE_BITS) - 1)

def RansEncInit():
    return RANS_BYTE_L

def RansEncPut(r, out_buf, start, freq):
    x_max = freq << ENC_RENORM_SHIFT_BITS
    while r >= x_max:
        out_buf.append(r & 0xff)
        r >>= 8
    r = ((r // freq) << SCALE_BITS) + (r % freq) + start
    return r

def RansEncFlush(r, out_buf):
    out_buf.append((r >> 0) & 0xff)
    out_buf.append((r >> 8) & 0xff)
    out_buf.append((r >> 16) & 0xff)
    out_buf.append((r >> 24) & 0xff)

def RansDecInit(buf, ptr_index=0):
    # read 4 bytes little-endian
    r = (int(buf[ptr_index]) | (int(buf[ptr_index+1]) << 8) | (int(buf[ptr_index+2]) << 16) | (int(buf[ptr_index+3]) << 24))
    return r, ptr_index + 4

def RansDecGet(r):
    return r & DEC_MASK

def RansDecAdvance(r, buf, ptr_index, start, freq):
    r = freq * (r >> SCALE_BITS) + (r & DEC_MASK) - start
    while r < RANS_BYTE_L:
        r = (r << 8) | int(buf[ptr_index])
        ptr_index += 1
    return r, ptr_index

def pmf_to_quantized_cdf(pmf: List[float], precision: int):
    cdf = [0] * (len(pmf) + 1)
    for i, p in enumerate(pmf):
        cdf[i+1] = int(round(p * (1 << precision) + 0.5))
    total = sum(cdf)
    if total == 0:
        total = 1
    for i in range(len(cdf)):
        cdf[i] = int(((1 << precision) * cdf[i]) / total)
    for i in range(1, len(cdf)):
        cdf[i] += cdf[i-1]
    cdf[-1] = 1 << precision

    # repair zeros
    n = len(cdf) - 1
    for i in range(n):
        if cdf[i] == cdf[i+1]:
            best_freq = 0xffffffff
            best_j = -1
            for j in range(n):
                freq = cdf[j+1] - cdf[j]
                if freq > 1 and freq < best_freq:
                    best_freq = freq
                    best_j = j
            assert best_j != -1
            if best_j < i:
                for j in range(best_j+1, i+1):
                    cdf[j] -= 1
            else:
                for j in range(i+1, best_j+1):
                    cdf[j] += 1
    return cdf

class RansEncoderLib:
    def __init__(self):
        self._stream = bytearray()
        self._ransSymbols = []
        self._cdfs_sizes = []
        self._offsets = []
        self._pending = []

    def add_cdf(self, cdfs: List[List[int]], cdfs_sizes: List[int], offsets: List[int]):
        grp = []
        for cdf in cdfs:
            sym = []
            for j in range(len(cdf)-1):
                start = int(cdf[j])
                rng = int(cdf[j+1] - cdf[j])
                sym.append((start, rng))
            grp.append(sym)
        self._ransSymbols.append(grp)
        self._cdfs_sizes.append([int(x) for x in cdfs_sizes])
        self._offsets.append([int(x) for x in offsets])
        return len(self._ransSymbols) - 1

    def empty_cdf_buffer(self):
        self._ransSymbols.clear()
        self._cdfs_sizes.clear()
        self._offsets.clear()

    def encode_y(self, symbols, cdf_group_index):
        arr = [int(x) for x in np.asarray(symbols).ravel().tolist()]
        self._pending.append(("y", arr, int(cdf_group_index)))

    def encode_z(self, symbols, cdf_group_index, start_offset, per_channel_size):
        arr = [int(x) for x in np.asarray(symbols).ravel().tolist()]
        self._pending.append(("z", arr, int(cdf_group_index), int(start_offset), int(per_channel_size)))

    def flush(self):
        out = []
        r = RansEncInit()
        for task in reversed(self._pending):
            if task[0] == "y":
                _, symbols, group = task
                rans_sym_grp = self._ransSymbols[group]
                for combined in reversed(symbols):
                    cdf_idx = combined & 0xff
                    s = combined >> 8
                    if cdf_idx < len(rans_sym_grp) and isinstance(rans_sym_grp[cdf_idx], (list, tuple)):
                        cdf_list = rans_sym_grp[cdf_idx]
                    else:
                        cdf_list = rans_sym_grp[0]
                    entry = cdf_list[s]
                    start = int(entry[0])
                    rng = int(entry[1])
                    r = RansEncPut(r, out, start, rng)
            elif task[0] == "z":
                _, symbols, group, start_offset, per_channel = task
                rans_sym_grp = self._ransSymbols[group]
                for i in range(len(symbols)-1, -1, -1):
                    cdf_idx = i // per_channel + start_offset
                    if cdf_idx < len(rans_sym_grp) and isinstance(rans_sym_grp[cdf_idx], (list, tuple)):
                        cdf_list = rans_sym_grp[cdf_idx]
                    else:
                        cdf_list = rans_sym_grp[0]
                    val = symbols[i]
                    entry = cdf_list[val]
                    start = int(entry[0])
                    rng = int(entry[1])
                    r = RansEncPut(r, out, start, rng)
        RansEncFlush(r, out)
        self._stream = bytearray(reversed(out))
        self._pending.clear()

    def get_encoded_stream(self):
        return bytes(self._stream)

    def reset(self):
        self._stream = bytearray()
        self._pending.clear()

class RansDecoderLib:
    def __init__(self):
        self._stream = bytearray()
        self._ptr = 0
        self._rans = 0
        self._cdfs = []
        self._cdfs_sizes = []
        self._offsets = []
        self._decoded = []

    def set_stream(self, encoded: bytes):
        # store raw stream
        self._stream = bytearray(encoded)
        # helper to test if r produces a valid cum against known cdfs
        def is_valid_r(r):
            cum = RansDecGet(r)
            # find a reasonable maximum cumulative frequency from first cdf group if available
            if not self._cdfs:
                # no cdf known yet; consider any r as valid for now
                return True
            # compute max_cdf = max of last entries across all cdfs in first group
            max_cdf = 0
            for row in self._cdfs[0]:
                if len(row) > 0:
                    max_cdf = max(max_cdf, int(row[-1]))
            return cum < max_cdf if max_cdf > 0 else True

        n = len(self._stream)
        if n < 4:
            raise ValueError("Encoded stream too short to contain rANS state")

        # try reading first 4 bytes as little-endian
        r1, ptr1 = RansDecInit(self._stream, 0)
        valid1 = is_valid_r(r1)
        # try reading last 4 bytes (little-endian)
        r2_bytes_idx = n - 4
        r2 = (int(self._stream[r2_bytes_idx]) | (int(self._stream[r2_bytes_idx+1]) << 8) |
              (int(self._stream[r2_bytes_idx+2]) << 16) | (int(self._stream[r2_bytes_idx+3]) << 24))
        # When reading from end, pointer should be at start of stream (0)
        ptr2 = 0
        valid2 = is_valid_r(r2)

        # pick the valid one; prefer r1 if both valid
        if valid1:
            self._rans = r1
            self._ptr = ptr1
        elif valid2:
            self._rans = r2
            self._ptr = ptr2
        else:
            # fallback: set r from first 4 bytes (default) but warn
            self._rans = r1
            self._ptr = ptr1
            # raise helpful diagnostic if later decode fails
            # We'll keep this as a non-fatal fallback so we can see next error
        return

    def add_cdf(self, cdfs, sizes, offsets):
        self._cdfs.append([list(map(int, row)) for row in cdfs])
        self._cdfs_sizes.append([int(x) for x in sizes])
        self._offsets.append([int(x) for x in offsets])
        return len(self._cdfs) - 1

    def empty_cdf_buffer(self):
        self._cdfs.clear()
        self._cdfs_sizes.clear()
        self._offsets.clear()

    def decode_y(self, indexes, cdf_group_index):
        idxs = [int(x) for x in np.asarray(indexes).ravel().tolist()]
        cdfs = self._cdfs[cdf_group_index]
        offsets = self._offsets[cdf_group_index]
        decoded = []
        for idx in idxs:
            cdf = cdfs[idx]
            cum = RansDecGet(self._rans)
            s = 1
            while s < len(cdf) and cdf[s] <= cum:
                s += 1
            s -= 1
            start = int(cdf[s])
            rng = int(cdf[s+1] - cdf[s])
            self._rans, self._ptr = RansDecAdvance(self._rans, self._stream, self._ptr, start, rng)
            decoded.append(int(s + offsets[idx]))
        self._decoded = decoded

    def get_decoded_tensor(self):
        return np.array(self._decoded, dtype=np.int8)
'''.lstrip()

# Write patched file
file_path.write_text(new_file_text)
print("Patched file written:", file_path)

# Unload stale modules
to_unload = [m for m in list(sys.modules.keys()) if m.startswith("src.python") or m in ("mlcodec_rans_py","codec_loader")]
for m in to_unload:
    sys.modules.pop(m, None)
print("Unloaded modules count:", len(to_unload))

# Re-import loader and run smoke test
loader = importlib.import_module("src.python.codec_loader")
importlib.reload(loader)
print("Backend after reload:", loader.BACKEND)

# run the same smoke test
import numpy as np
pmf = [0.2, 0.5, 0.3]
precision = 12
cdf = loader.pmf_to_quantized_cdf(pmf, precision)
cdfs_arr = np.array([cdf], dtype=np.int32)
cdfs_sizes = np.array([len(cdf)], dtype=np.int32)
offsets = np.array([0], dtype=np.int32)

enc = loader.RansEncoder()
idx = enc.add_cdf(cdfs_arr, cdfs_sizes, offsets)
print("cdf index:", idx)

symbols = np.array([ (0 & 0xff) | (1 << 8), (0 & 0xff) | (2 << 8) ], dtype=np.int16)
enc.encode_y(symbols, idx)
enc.flush()
stream = enc.get_encoded_stream()
print("Encoded stream len:", len(stream))
print("Encoded bytes:", np.asarray(stream, dtype=np.uint8).tolist())

dec = loader.RansDecoder()
dec.add_cdf(cdfs_arr, cdfs_sizes, offsets)
dec.set_stream(stream)
dec.decode_y(np.array([0,0], dtype=np.uint8), idx)
out = dec.get_decoded_tensor()
print("Decoded result:", out.tolist())
